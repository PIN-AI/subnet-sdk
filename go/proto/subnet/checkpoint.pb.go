// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.8
// 	protoc        v4.25.3
// source: proto/subnet/checkpoint.proto

package pb

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type CommitmentRoots struct {
	state            protoimpl.MessageState `protogen:"open.v1"`
	AgentRoot        []byte                 `protobuf:"bytes,1,opt,name=agent_root,json=agentRoot,proto3" json:"agent_root,omitempty"`
	AgentServiceRoot []byte                 `protobuf:"bytes,2,opt,name=agent_service_root,json=agentServiceRoot,proto3" json:"agent_service_root,omitempty"`
	RankRoot         []byte                 `protobuf:"bytes,3,opt,name=rank_root,json=rankRoot,proto3" json:"rank_root,omitempty"`
	MetricsRoot      []byte                 `protobuf:"bytes,4,opt,name=metrics_root,json=metricsRoot,proto3" json:"metrics_root,omitempty"`
	DataUsageRoot    []byte                 `protobuf:"bytes,5,opt,name=data_usage_root,json=dataUsageRoot,proto3" json:"data_usage_root,omitempty"`
	StateRoot        []byte                 `protobuf:"bytes,6,opt,name=state_root,json=stateRoot,proto3" json:"state_root,omitempty"`
	EventRoot        []byte                 `protobuf:"bytes,7,opt,name=event_root,json=eventRoot,proto3" json:"event_root,omitempty"`
	CrossSubnetRoot  []byte                 `protobuf:"bytes,8,opt,name=cross_subnet_root,json=crossSubnetRoot,proto3" json:"cross_subnet_root,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *CommitmentRoots) Reset() {
	*x = CommitmentRoots{}
	mi := &file_proto_subnet_checkpoint_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CommitmentRoots) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CommitmentRoots) ProtoMessage() {}

func (x *CommitmentRoots) ProtoReflect() protoreflect.Message {
	mi := &file_proto_subnet_checkpoint_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CommitmentRoots.ProtoReflect.Descriptor instead.
func (*CommitmentRoots) Descriptor() ([]byte, []int) {
	return file_proto_subnet_checkpoint_proto_rawDescGZIP(), []int{0}
}

func (x *CommitmentRoots) GetAgentRoot() []byte {
	if x != nil {
		return x.AgentRoot
	}
	return nil
}

func (x *CommitmentRoots) GetAgentServiceRoot() []byte {
	if x != nil {
		return x.AgentServiceRoot
	}
	return nil
}

func (x *CommitmentRoots) GetRankRoot() []byte {
	if x != nil {
		return x.RankRoot
	}
	return nil
}

func (x *CommitmentRoots) GetMetricsRoot() []byte {
	if x != nil {
		return x.MetricsRoot
	}
	return nil
}

func (x *CommitmentRoots) GetDataUsageRoot() []byte {
	if x != nil {
		return x.DataUsageRoot
	}
	return nil
}

func (x *CommitmentRoots) GetStateRoot() []byte {
	if x != nil {
		return x.StateRoot
	}
	return nil
}

func (x *CommitmentRoots) GetEventRoot() []byte {
	if x != nil {
		return x.EventRoot
	}
	return nil
}

func (x *CommitmentRoots) GetCrossSubnetRoot() []byte {
	if x != nil {
		return x.CrossSubnetRoot
	}
	return nil
}

type DACommitment struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Kind          string                 `protobuf:"bytes,1,opt,name=kind,proto3" json:"kind,omitempty"`       // e.g., IPFS, EigenDA
	Pointer       string                 `protobuf:"bytes,2,opt,name=pointer,proto3" json:"pointer,omitempty"` // CID or blob id
	SizeHint      uint64                 `protobuf:"varint,3,opt,name=size_hint,json=sizeHint,proto3" json:"size_hint,omitempty"`
	SegmentHashes [][]byte               `protobuf:"bytes,4,rep,name=segment_hashes,json=segmentHashes,proto3" json:"segment_hashes,omitempty"`
	Expiry        int64                  `protobuf:"varint,5,opt,name=expiry,proto3" json:"expiry,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DACommitment) Reset() {
	*x = DACommitment{}
	mi := &file_proto_subnet_checkpoint_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DACommitment) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DACommitment) ProtoMessage() {}

func (x *DACommitment) ProtoReflect() protoreflect.Message {
	mi := &file_proto_subnet_checkpoint_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DACommitment.ProtoReflect.Descriptor instead.
func (*DACommitment) Descriptor() ([]byte, []int) {
	return file_proto_subnet_checkpoint_proto_rawDescGZIP(), []int{1}
}

func (x *DACommitment) GetKind() string {
	if x != nil {
		return x.Kind
	}
	return ""
}

func (x *DACommitment) GetPointer() string {
	if x != nil {
		return x.Pointer
	}
	return ""
}

func (x *DACommitment) GetSizeHint() uint64 {
	if x != nil {
		return x.SizeHint
	}
	return 0
}

func (x *DACommitment) GetSegmentHashes() [][]byte {
	if x != nil {
		return x.SegmentHashes
	}
	return nil
}

func (x *DACommitment) GetExpiry() int64 {
	if x != nil {
		return x.Expiry
	}
	return 0
}

type EpochSlot struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Epoch         uint64                 `protobuf:"varint,1,opt,name=epoch,proto3" json:"epoch,omitempty"`
	Slot          uint64                 `protobuf:"varint,2,opt,name=slot,proto3" json:"slot,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EpochSlot) Reset() {
	*x = EpochSlot{}
	mi := &file_proto_subnet_checkpoint_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EpochSlot) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EpochSlot) ProtoMessage() {}

func (x *EpochSlot) ProtoReflect() protoreflect.Message {
	mi := &file_proto_subnet_checkpoint_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EpochSlot.ProtoReflect.Descriptor instead.
func (*EpochSlot) Descriptor() ([]byte, []int) {
	return file_proto_subnet_checkpoint_proto_rawDescGZIP(), []int{2}
}

func (x *EpochSlot) GetEpoch() uint64 {
	if x != nil {
		return x.Epoch
	}
	return 0
}

func (x *EpochSlot) GetSlot() uint64 {
	if x != nil {
		return x.Slot
	}
	return 0
}

type CheckpointHeader struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	SubnetId       string                 `protobuf:"bytes,1,opt,name=subnet_id,json=subnetId,proto3" json:"subnet_id,omitempty"`
	Epoch          uint64                 `protobuf:"varint,2,opt,name=epoch,proto3" json:"epoch,omitempty"`
	ParentCpHash   []byte                 `protobuf:"bytes,3,opt,name=parent_cp_hash,json=parentCpHash,proto3" json:"parent_cp_hash,omitempty"`
	Timestamp      int64                  `protobuf:"varint,4,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	Version        uint32                 `protobuf:"varint,5,opt,name=version,proto3" json:"version,omitempty"`
	ParamsHash     []byte                 `protobuf:"bytes,6,opt,name=params_hash,json=paramsHash,proto3" json:"params_hash,omitempty"`
	Roots          *CommitmentRoots       `protobuf:"bytes,7,opt,name=roots,proto3" json:"roots,omitempty"`
	DaCommitments  []*DACommitment        `protobuf:"bytes,8,rep,name=da_commitments,json=daCommitments,proto3" json:"da_commitments,omitempty"`
	ValidatorSetId string                 `protobuf:"bytes,9,opt,name=validator_set_id,json=validatorSetId,proto3" json:"validator_set_id,omitempty"`
	Stats          []byte                 `protobuf:"bytes,11,opt,name=stats,proto3" json:"stats,omitempty"`                    // optional serialized stats
	AuxHash        []byte                 `protobuf:"bytes,12,opt,name=aux_hash,json=auxHash,proto3" json:"aux_hash,omitempty"` // auxiliary hash
	EpochSlot      *EpochSlot             `protobuf:"bytes,13,opt,name=epoch_slot,json=epochSlot,proto3" json:"epoch_slot,omitempty"`
	// Optional extensions to align with updated protocol
	AssignmentsRoot      []byte `protobuf:"bytes,14,opt,name=assignments_root,json=assignmentsRoot,proto3" json:"assignments_root,omitempty"`                // optional
	ValidationCommitment []byte `protobuf:"bytes,15,opt,name=validation_commitment,json=validationCommitment,proto3" json:"validation_commitment,omitempty"` // optional
	PolicyRoot           []byte `protobuf:"bytes,16,opt,name=policy_root,json=policyRoot,proto3" json:"policy_root,omitempty"`                               // optional
	// Signature aggregation (ECDSA with bitmap)
	Signatures    *CheckpointSignatures `protobuf:"bytes,17,opt,name=signatures,proto3" json:"signatures,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CheckpointHeader) Reset() {
	*x = CheckpointHeader{}
	mi := &file_proto_subnet_checkpoint_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CheckpointHeader) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CheckpointHeader) ProtoMessage() {}

func (x *CheckpointHeader) ProtoReflect() protoreflect.Message {
	mi := &file_proto_subnet_checkpoint_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CheckpointHeader.ProtoReflect.Descriptor instead.
func (*CheckpointHeader) Descriptor() ([]byte, []int) {
	return file_proto_subnet_checkpoint_proto_rawDescGZIP(), []int{3}
}

func (x *CheckpointHeader) GetSubnetId() string {
	if x != nil {
		return x.SubnetId
	}
	return ""
}

func (x *CheckpointHeader) GetEpoch() uint64 {
	if x != nil {
		return x.Epoch
	}
	return 0
}

func (x *CheckpointHeader) GetParentCpHash() []byte {
	if x != nil {
		return x.ParentCpHash
	}
	return nil
}

func (x *CheckpointHeader) GetTimestamp() int64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

func (x *CheckpointHeader) GetVersion() uint32 {
	if x != nil {
		return x.Version
	}
	return 0
}

func (x *CheckpointHeader) GetParamsHash() []byte {
	if x != nil {
		return x.ParamsHash
	}
	return nil
}

func (x *CheckpointHeader) GetRoots() *CommitmentRoots {
	if x != nil {
		return x.Roots
	}
	return nil
}

func (x *CheckpointHeader) GetDaCommitments() []*DACommitment {
	if x != nil {
		return x.DaCommitments
	}
	return nil
}

func (x *CheckpointHeader) GetValidatorSetId() string {
	if x != nil {
		return x.ValidatorSetId
	}
	return ""
}

func (x *CheckpointHeader) GetStats() []byte {
	if x != nil {
		return x.Stats
	}
	return nil
}

func (x *CheckpointHeader) GetAuxHash() []byte {
	if x != nil {
		return x.AuxHash
	}
	return nil
}

func (x *CheckpointHeader) GetEpochSlot() *EpochSlot {
	if x != nil {
		return x.EpochSlot
	}
	return nil
}

func (x *CheckpointHeader) GetAssignmentsRoot() []byte {
	if x != nil {
		return x.AssignmentsRoot
	}
	return nil
}

func (x *CheckpointHeader) GetValidationCommitment() []byte {
	if x != nil {
		return x.ValidationCommitment
	}
	return nil
}

func (x *CheckpointHeader) GetPolicyRoot() []byte {
	if x != nil {
		return x.PolicyRoot
	}
	return nil
}

func (x *CheckpointHeader) GetSignatures() *CheckpointSignatures {
	if x != nil {
		return x.Signatures
	}
	return nil
}

// ECDSA signature aggregation with bitmap
type CheckpointSignatures struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	EcdsaSignatures [][]byte               `protobuf:"bytes,1,rep,name=ecdsa_signatures,json=ecdsaSignatures,proto3" json:"ecdsa_signatures,omitempty"` // list of ECDSA signatures
	SignersBitmap   []byte                 `protobuf:"bytes,2,opt,name=signers_bitmap,json=signersBitmap,proto3" json:"signers_bitmap,omitempty"`       // bitmap indicating which validators signed
	SignatureCount  uint32                 `protobuf:"varint,3,opt,name=signature_count,json=signatureCount,proto3" json:"signature_count,omitempty"`   // number of signatures
	TotalWeight     uint64                 `protobuf:"varint,4,opt,name=total_weight,json=totalWeight,proto3" json:"total_weight,omitempty"`            // total weight of signers
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *CheckpointSignatures) Reset() {
	*x = CheckpointSignatures{}
	mi := &file_proto_subnet_checkpoint_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CheckpointSignatures) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CheckpointSignatures) ProtoMessage() {}

func (x *CheckpointSignatures) ProtoReflect() protoreflect.Message {
	mi := &file_proto_subnet_checkpoint_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CheckpointSignatures.ProtoReflect.Descriptor instead.
func (*CheckpointSignatures) Descriptor() ([]byte, []int) {
	return file_proto_subnet_checkpoint_proto_rawDescGZIP(), []int{4}
}

func (x *CheckpointSignatures) GetEcdsaSignatures() [][]byte {
	if x != nil {
		return x.EcdsaSignatures
	}
	return nil
}

func (x *CheckpointSignatures) GetSignersBitmap() []byte {
	if x != nil {
		return x.SignersBitmap
	}
	return nil
}

func (x *CheckpointSignatures) GetSignatureCount() uint32 {
	if x != nil {
		return x.SignatureCount
	}
	return 0
}

func (x *CheckpointSignatures) GetTotalWeight() uint64 {
	if x != nil {
		return x.TotalWeight
	}
	return 0
}

type Signature struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Algo          string                 `protobuf:"bytes,1,opt,name=algo,proto3" json:"algo,omitempty"` // ECDSA-secp256k1
	Der           []byte                 `protobuf:"bytes,2,opt,name=der,proto3" json:"der,omitempty"`
	Pubkey        []byte                 `protobuf:"bytes,3,opt,name=pubkey,proto3" json:"pubkey,omitempty"`
	MsgHash       []byte                 `protobuf:"bytes,4,opt,name=msg_hash,json=msgHash,proto3" json:"msg_hash,omitempty"`
	SignerId      string                 `protobuf:"bytes,5,opt,name=signer_id,json=signerId,proto3" json:"signer_id,omitempty"` // validator id
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Signature) Reset() {
	*x = Signature{}
	mi := &file_proto_subnet_checkpoint_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Signature) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Signature) ProtoMessage() {}

func (x *Signature) ProtoReflect() protoreflect.Message {
	mi := &file_proto_subnet_checkpoint_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Signature.ProtoReflect.Descriptor instead.
func (*Signature) Descriptor() ([]byte, []int) {
	return file_proto_subnet_checkpoint_proto_rawDescGZIP(), []int{5}
}

func (x *Signature) GetAlgo() string {
	if x != nil {
		return x.Algo
	}
	return ""
}

func (x *Signature) GetDer() []byte {
	if x != nil {
		return x.Der
	}
	return nil
}

func (x *Signature) GetPubkey() []byte {
	if x != nil {
		return x.Pubkey
	}
	return nil
}

func (x *Signature) GetMsgHash() []byte {
	if x != nil {
		return x.MsgHash
	}
	return nil
}

func (x *Signature) GetSignerId() string {
	if x != nil {
		return x.SignerId
	}
	return ""
}

var File_proto_subnet_checkpoint_proto protoreflect.FileDescriptor

const file_proto_subnet_checkpoint_proto_rawDesc = "" +
	"\n" +
	"\x1dproto/subnet/checkpoint.proto\x12\tsubnet.v1\"\xb0\x02\n" +
	"\x0fCommitmentRoots\x12\x1d\n" +
	"\n" +
	"agent_root\x18\x01 \x01(\fR\tagentRoot\x12,\n" +
	"\x12agent_service_root\x18\x02 \x01(\fR\x10agentServiceRoot\x12\x1b\n" +
	"\trank_root\x18\x03 \x01(\fR\brankRoot\x12!\n" +
	"\fmetrics_root\x18\x04 \x01(\fR\vmetricsRoot\x12&\n" +
	"\x0fdata_usage_root\x18\x05 \x01(\fR\rdataUsageRoot\x12\x1d\n" +
	"\n" +
	"state_root\x18\x06 \x01(\fR\tstateRoot\x12\x1d\n" +
	"\n" +
	"event_root\x18\a \x01(\fR\teventRoot\x12*\n" +
	"\x11cross_subnet_root\x18\b \x01(\fR\x0fcrossSubnetRoot\"\x98\x01\n" +
	"\fDACommitment\x12\x12\n" +
	"\x04kind\x18\x01 \x01(\tR\x04kind\x12\x18\n" +
	"\apointer\x18\x02 \x01(\tR\apointer\x12\x1b\n" +
	"\tsize_hint\x18\x03 \x01(\x04R\bsizeHint\x12%\n" +
	"\x0esegment_hashes\x18\x04 \x03(\fR\rsegmentHashes\x12\x16\n" +
	"\x06expiry\x18\x05 \x01(\x03R\x06expiry\"5\n" +
	"\tEpochSlot\x12\x14\n" +
	"\x05epoch\x18\x01 \x01(\x04R\x05epoch\x12\x12\n" +
	"\x04slot\x18\x02 \x01(\x04R\x04slot\"\x88\x05\n" +
	"\x10CheckpointHeader\x12\x1b\n" +
	"\tsubnet_id\x18\x01 \x01(\tR\bsubnetId\x12\x14\n" +
	"\x05epoch\x18\x02 \x01(\x04R\x05epoch\x12$\n" +
	"\x0eparent_cp_hash\x18\x03 \x01(\fR\fparentCpHash\x12\x1c\n" +
	"\ttimestamp\x18\x04 \x01(\x03R\ttimestamp\x12\x18\n" +
	"\aversion\x18\x05 \x01(\rR\aversion\x12\x1f\n" +
	"\vparams_hash\x18\x06 \x01(\fR\n" +
	"paramsHash\x120\n" +
	"\x05roots\x18\a \x01(\v2\x1a.subnet.v1.CommitmentRootsR\x05roots\x12>\n" +
	"\x0eda_commitments\x18\b \x03(\v2\x17.subnet.v1.DACommitmentR\rdaCommitments\x12(\n" +
	"\x10validator_set_id\x18\t \x01(\tR\x0evalidatorSetId\x12\x14\n" +
	"\x05stats\x18\v \x01(\fR\x05stats\x12\x19\n" +
	"\baux_hash\x18\f \x01(\fR\aauxHash\x123\n" +
	"\n" +
	"epoch_slot\x18\r \x01(\v2\x14.subnet.v1.EpochSlotR\tepochSlot\x12)\n" +
	"\x10assignments_root\x18\x0e \x01(\fR\x0fassignmentsRoot\x123\n" +
	"\x15validation_commitment\x18\x0f \x01(\fR\x14validationCommitment\x12\x1f\n" +
	"\vpolicy_root\x18\x10 \x01(\fR\n" +
	"policyRoot\x12?\n" +
	"\n" +
	"signatures\x18\x11 \x01(\v2\x1f.subnet.v1.CheckpointSignaturesR\n" +
	"signatures\"\xb4\x01\n" +
	"\x14CheckpointSignatures\x12)\n" +
	"\x10ecdsa_signatures\x18\x01 \x03(\fR\x0fecdsaSignatures\x12%\n" +
	"\x0esigners_bitmap\x18\x02 \x01(\fR\rsignersBitmap\x12'\n" +
	"\x0fsignature_count\x18\x03 \x01(\rR\x0esignatureCount\x12!\n" +
	"\ftotal_weight\x18\x04 \x01(\x04R\vtotalWeight\"\x81\x01\n" +
	"\tSignature\x12\x12\n" +
	"\x04algo\x18\x01 \x01(\tR\x04algo\x12\x10\n" +
	"\x03der\x18\x02 \x01(\fR\x03der\x12\x16\n" +
	"\x06pubkey\x18\x03 \x01(\fR\x06pubkey\x12\x19\n" +
	"\bmsg_hash\x18\x04 \x01(\fR\amsgHash\x12\x1b\n" +
	"\tsigner_id\x18\x05 \x01(\tR\bsignerIdB\x18Z\x16subnet/proto/subnet;pbb\x06proto3"

var (
	file_proto_subnet_checkpoint_proto_rawDescOnce sync.Once
	file_proto_subnet_checkpoint_proto_rawDescData []byte
)

func file_proto_subnet_checkpoint_proto_rawDescGZIP() []byte {
	file_proto_subnet_checkpoint_proto_rawDescOnce.Do(func() {
		file_proto_subnet_checkpoint_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_proto_subnet_checkpoint_proto_rawDesc), len(file_proto_subnet_checkpoint_proto_rawDesc)))
	})
	return file_proto_subnet_checkpoint_proto_rawDescData
}

var file_proto_subnet_checkpoint_proto_msgTypes = make([]protoimpl.MessageInfo, 6)
var file_proto_subnet_checkpoint_proto_goTypes = []any{
	(*CommitmentRoots)(nil),      // 0: subnet.v1.CommitmentRoots
	(*DACommitment)(nil),         // 1: subnet.v1.DACommitment
	(*EpochSlot)(nil),            // 2: subnet.v1.EpochSlot
	(*CheckpointHeader)(nil),     // 3: subnet.v1.CheckpointHeader
	(*CheckpointSignatures)(nil), // 4: subnet.v1.CheckpointSignatures
	(*Signature)(nil),            // 5: subnet.v1.Signature
}
var file_proto_subnet_checkpoint_proto_depIdxs = []int32{
	0, // 0: subnet.v1.CheckpointHeader.roots:type_name -> subnet.v1.CommitmentRoots
	1, // 1: subnet.v1.CheckpointHeader.da_commitments:type_name -> subnet.v1.DACommitment
	2, // 2: subnet.v1.CheckpointHeader.epoch_slot:type_name -> subnet.v1.EpochSlot
	4, // 3: subnet.v1.CheckpointHeader.signatures:type_name -> subnet.v1.CheckpointSignatures
	4, // [4:4] is the sub-list for method output_type
	4, // [4:4] is the sub-list for method input_type
	4, // [4:4] is the sub-list for extension type_name
	4, // [4:4] is the sub-list for extension extendee
	0, // [0:4] is the sub-list for field type_name
}

func init() { file_proto_subnet_checkpoint_proto_init() }
func file_proto_subnet_checkpoint_proto_init() {
	if File_proto_subnet_checkpoint_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_proto_subnet_checkpoint_proto_rawDesc), len(file_proto_subnet_checkpoint_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   6,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_proto_subnet_checkpoint_proto_goTypes,
		DependencyIndexes: file_proto_subnet_checkpoint_proto_depIdxs,
		MessageInfos:      file_proto_subnet_checkpoint_proto_msgTypes,
	}.Build()
	File_proto_subnet_checkpoint_proto = out.File
	file_proto_subnet_checkpoint_proto_goTypes = nil
	file_proto_subnet_checkpoint_proto_depIdxs = nil
}
